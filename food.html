<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>원형 내부 음식 배치 + 드래그 이동 (수정본)</title>
<style>
  body {
    margin: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
  }

  .stage {
    position: relative;
    width: 926px;
    height: 574px;
    background: url('img/food/bg.png') no-repeat center center;
    background-size: contain;
  }

  .circle {
    position: absolute;
    width: 342px;
    height: 342px;
    border-radius: 50%;
    background: rgba(255, 150, 150, 0.25);
    top: 126px;
    left: 83px;
    overflow: visible;
  }

  .box {
    position: absolute;
    width: 333px;
    height: 431px;
    background: rgba(150, 150, 255, 0.25);
    top: 71px;
    right: 76px;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .food {
    position: absolute;
    user-select: none;
    cursor: grab;
    transition: transform 0.15s ease;
    will-change: transform, left, top;
  }

  .food.dragging {
    opacity: 0.9;
    cursor: grabbing;
    z-index: 999;
    transform: scale(1.06);
    transition: none;
  }
</style>
</head>
<body>

<div class="stage" id="stage">
  <div class="circle" id="circle"></div>
  <div class="box" id="box"></div>
</div>

<script>
  const stage = document.getElementById('stage');
  const circle = document.getElementById("circle");
  const box = document.getElementById("box");

  const foods = [
    { name: "BREATHE", size: [135, 47] },
    { name: "CORRECT", size: [121, 45] },
    { name: "DIG", size: [55, 48] },
    { name: "ELECTRIC", size: [130, 43] },
    { name: "GLASS", size: [106, 32] },
    { name: "KID", size: [58, 44] },
    { name: "NETFLIX", size: [137, 36] },
    { name: "SUSTAIN", size: [121, 43] },
    { name: "TRICK", size: [88, 36] },
    { name: "XERASIA", size: [143, 46] }
  ];

  const circleRadius = 342 / 2;
  const placedFoods = [];
  const buffer = 5;

  function insideCircleAllCorners(x, y, w, h, radius) {
    const cx = radius, cy = radius;
    const corners = [
      [x, y],
      [x + w, y],
      [x, y + h],
      [x + w, y + h]
    ];
    return corners.every(([px, py]) => {
      const dx = px - cx;
      const dy = py - cy;
      return Math.sqrt(dx * dx + dy * dy) <= radius;
    });
  }

  // 1) 이미지들 circle 안에 배치 (좌표는 circle 내부 기준)
  foods.forEach(food => {
    const img = document.createElement("img");
    img.src = `img/food/${food.name}.png`;
    img.className = "food";

    const [w, h] = food.size;
    img.style.width = `${w}px`;
    img.style.height = `${h}px`;

    let x, y;
    let tries = 0;
    const maxTries = 1000;

    while (tries < maxTries) {
      const angle = Math.random() * 2 * Math.PI;
      const r = Math.random() * (circleRadius - Math.max(w, h) / 2);
      const cx = circleRadius + Math.cos(angle) * r;
      const cy = circleRadius + Math.sin(angle) * r;

      x = cx - w / 2;
      y = cy - h / 2;

      if (!insideCircleAllCorners(x, y, w, h, circleRadius)) {
        tries++;
        continue;
      }

      let overlap = false;
      for (const p of placedFoods) {
        const dx = (x + w / 2) - (p.x + p.w / 2);
        const dy = (y + h / 2) - (p.y + p.h / 2);
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < (Math.max(w, p.w) / 2) - buffer) {
          overlap = true;
          break;
        }
      }

      if (!overlap) break;
      tries++;
    }

    if (tries >= maxTries) {
      x = circleRadius - w / 2;
      y = circleRadius - h / 2;
    }

    // 위치는 circle 내부 좌표 (circle의 좌상단이 0,0)
    img.style.left = `${x}px`;
    img.style.top = `${y}px`;

    // 원래 위치를 circle 기준으로 저장 (숫자)
    img.dataset.originalLeft = x;
    img.dataset.originalTop = y;
    img.dataset.inBox = "false";

    placedFoods.push({ x, y, w, h });
    circle.appendChild(img);
  });

  // === 드래그 로직 (핵심 수정) ===
  let dragged = null;
  let offsetX = 0, offsetY = 0;
  let initialParent = null;
  let initialLeftPx = 0, initialTopPx = 0;

  // helper: 화면상 rect -> px left/top relative to stage
  function clientToStagePos(clientX, clientY) {
    const stageRect = stage.getBoundingClientRect();
    return {
      x: clientX - stageRect.left,
      y: clientY - stageRect.top
    };
  }

  // attach listeners to dynamically created .food elements
  function enableDraggingForFoods() {
    document.querySelectorAll(".food").forEach(img => {
      img.addEventListener("mousedown", (e) => {
        e.preventDefault();
        dragged = img;
        dragged.classList.add("dragging");

        // compute current absolute (stage-based) left/top of the img
        const imgRect = dragged.getBoundingClientRect();
        const stageRect = stage.getBoundingClientRect();
        initialLeftPx = imgRect.left - stageRect.left;
        initialTopPx = imgRect.top - stageRect.top;

        // keep track of parent so we can restore if needed
        initialParent = dragged.parentElement;

        // offset between mouse and top-left of image (client coords)
        offsetX = e.clientX - imgRect.left;
        offsetY = e.clientY - imgRect.top;

        // move the element to be direct child of stage (so all coords are stage-based)
        // but maintain same visual position: set left/top to initialLeftPx/Top
        stage.appendChild(dragged);
        dragged.style.left = initialLeftPx + "px";
        dragged.style.top = initialTopPx + "px";

        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);
      });
    });
  }

  function onMouseMove(e) {
    if (!dragged) return;
    const pos = clientToStagePos(e.clientX, e.clientY);
    let x = pos.x - offsetX;
    let y = pos.y - offsetY;

    // clamp within stage
    x = Math.max(0, Math.min(x, stage.clientWidth - dragged.offsetWidth));
    y = Math.max(0, Math.min(y, stage.clientHeight - dragged.offsetHeight));

    dragged.style.left = x + "px";
    dragged.style.top = y + "px";
  }

  function onMouseUp(e) {
    if (!dragged) return;

    const imgRect = dragged.getBoundingClientRect();
    const boxRect = box.getBoundingClientRect();
    const stageRect = stage.getBoundingClientRect();

    const isInsideBox =
      imgRect.right > boxRect.left &&
      imgRect.left < boxRect.right &&
      imgRect.bottom > boxRect.top &&
      imgRect.top < boxRect.bottom;

    if (isInsideBox) {
      // 중앙 정렬 (박스 내부에서 중앙)
      const centerX = (boxRect.left - stageRect.left) + (boxRect.width - imgRect.width) / 2;
      const centerY = (boxRect.top - stageRect.top) + (boxRect.height - imgRect.height) / 2;

      dragged.style.left = `${centerX}px`;
      dragged.style.top = `${centerY}px`;
      dragged.dataset.inBox = "true";
    } else {
      // 원래 자리(원 내부)로 복귀: 원 내부 좌표로 다시 옮겨야 함.
      // 원 내부 좌표를 저장해둔 dataset.originalLeft/Top (circle 기준)
      const origLeft = parseFloat(dragged.dataset.originalLeft);
      const origTop = parseFloat(dragged.dataset.originalTop);

      // circle의 stage 기준 좌표
      const circleRect = circle.getBoundingClientRect();
      const stageRect2 = stage.getBoundingClientRect();
      const circleLeftStage = circleRect.left - stageRect2.left;
      const circleTopStage = circleRect.top - stageRect2.top;

      // set back to circle as parent and position in circle coords
      dragged.style.left = `${circleLeftStage + origLeft}px`;
      dragged.style.top = `${circleTopStage + origTop}px`;

      // move back under circle in DOM so its position becomes relative to stage visually,
      // but to keep consistent keep it as child of stage (we keep everything in stage while simpler).
      // If you prefer to return it as child of circle, uncomment the block below and adjust coordinates.
      // circle.appendChild(dragged);
      // dragged.style.left = `${origLeft}px`;
      // dragged.style.top = `${origTop}px`;
      dragged.dataset.inBox = "false";
    }

    // keep draggable even inside box (we leave element as child of stage)
    dragged.classList.remove("dragging");
    dragged = null;

    document.removeEventListener("mousemove", onMouseMove);
    document.removeEventListener("mouseup", onMouseUp);
  }

  // 초기 세팅
  enableDraggingForFoods();

  // 만약 이후에 음식이 동적으로 추가되면 enableDraggingForFoods() 다시 호출하면 됨.
</script>

</body>
</html>
