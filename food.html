<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>드래그 드랍 정렬</title>
<style>
  body {
    margin: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
  }
  .stage {
    position: relative;
    width: 926px;
    height: 574px;
    background: #ddd;
  }
  .circle {
    position: absolute;
    width: 342px;
    height: 342px;
    border-radius: 50%;
    background: rgba(255, 150, 150, 0.25);
    top: 126px;
    left: 83px;
  }
  .box {
    position: absolute;
    width: 333px;
    height: 431px;
    background: rgba(150, 150, 255, 0.25);
    top: 71px;
    right: 76px;
    overflow: hidden;
  }
  .food {
    position: absolute;
    cursor: grab;
    user-select: none;
    transition: transform .15s;
  }
  .food.dragging {
    opacity: 0.9;
    cursor: grabbing;
    z-index: 999;
    transform: scale(1.06);
    transition: none;
  }
</style>
</head>
<body>

<div class="stage" id="stage">
  <div class="circle" id="circle"></div>
  <div class="box" id="box"></div>
</div>

<script>
const stage = document.getElementById("stage");
const circle = document.getElementById("circle");
const box = document.getElementById("box");

const foods = [
  { name: "BREATHE", size: [135, 47] },
  { name: "CORRECT", size: [121, 45] },
  { name: "DIG", size: [55, 48] },
  { name: "ELECTRIC", size: [130, 43] },
  { name: "GLASS", size: [106, 32] },
  { name: "KID", size: [58, 44] },
  { name: "NETFLIX", size: [137, 36] },
  { name: "SUSTAIN", size: [121, 43] },
  { name: "TRICK", size: [88, 36] },
  { name: "XERASIA", size: [143, 46] }
];

let boxItems = [];
let dragged = null;
let offsetX = 0, offsetY = 0;
let originalX = 0, originalY = 0;

function clientToStagePos(clientX, clientY) {
  const rect = stage.getBoundingClientRect();
  return {
    x: clientX - rect.left,
    y: clientY - rect.top,
  };
}

function enableDragging(img) {
  img.addEventListener("mousedown", e => {
    dragged = img;
    dragged.classList.add("dragging");

    const rect = img.getBoundingClientRect();
    const stageRect = stage.getBoundingClientRect();

    originalX = rect.left - stageRect.left;
    originalY = rect.top - stageRect.top;

    offsetX = e.clientX - rect.left;
    offsetY = e.clientY - rect.top;

    stage.appendChild(img); // 위로 이동

    img.style.left = originalX + "px";
    img.style.top = originalY + "px";

    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });
}

function onMouseMove(e) {
  if (!dragged) return;
  const pos = clientToStagePos(e.clientX, e.clientY);
  dragged.style.left = `${pos.x - offsetX}px`;
  dragged.style.top = `${pos.y - offsetY}px`;
}

function updateBoxLayout(droppedImg) {
  const boxRect = box.getBoundingClientRect();
  const stageRect = stage.getBoundingClientRect();

  // ✅ Y 기준 정렬
  boxItems.sort((a, b) => a.offsetTop - b.offsetTop);

  const GAP = 2;

  // ✅ 간격 유지 (위 → 아래)
  for (let i = 1; i < boxItems.length; i++) {
    const prev = boxItems[i - 1];
    const curr = boxItems[i];
    const expectedTop = prev.offsetTop + prev.offsetHeight + GAP;

    if (curr.offsetTop < expectedTop) {
      curr.style.top = expectedTop + "px";
    }
  }

  // ✅ X 중앙 정렬
  boxItems.forEach(item => {
    item.style.left =
      (boxRect.left - stageRect.left) +
      (boxRect.width - item.offsetWidth) / 2 + "px";
  });

  // ✅ 박스 영역 벗어나지 않도록 조정
  const minTop = boxRect.top - stageRect.top;
  const maxTop = boxRect.bottom - stageRect.top - droppedImg.offsetHeight;

  let currTop = droppedImg.offsetTop;
  if (currTop < minTop) droppedImg.style.top = `${minTop}px`;
  if (currTop > maxTop) droppedImg.style.top = `${maxTop}px`;
}

function onMouseUp() {
  if (!dragged) return;

  const img = dragged;
  dragged.classList.remove("dragging");

  const rect = img.getBoundingClientRect();
  const boxRect = box.getBoundingClientRect();
  const stageRect = stage.getBoundingClientRect();

  const inside =
    rect.right > boxRect.left &&
    rect.left < boxRect.right &&
    rect.bottom > boxRect.top &&
    rect.top < boxRect.bottom;

  if (inside) {
    const newY = rect.top - stageRect.top;
    img.style.top = newY + "px";

    if (!boxItems.includes(img)) boxItems.push(img);
    updateBoxLayout(img);
  } else {
    img.style.left = originalX + "px";
    img.style.top = originalY + "px";

    const idx = boxItems.indexOf(img);
    if (idx >= 0) boxItems.splice(idx, 1);
  }

  dragged = null;
  document.removeEventListener("mousemove", onMouseMove);
  document.removeEventListener("mouseup", onMouseUp);
}

// ✅ 원형 영역에 랜덤 배치 (겹침 방지 간단)
foods.forEach(food => {
  const img = document.createElement("div");
  img.className = "food";
  img.style.width = food.size[0] + "px";
  img.style.height = food.size[1] + "px";
  img.textContent = food.name; // 테스트용

  img.style.left = Math.random() * 200 + "px";
  img.style.top = Math.random() * 200 + "px";

  enableDragging(img);
  circle.appendChild(img);
});
</script>

</body>
</html>
